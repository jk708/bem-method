## Что такое БЭМ?
`БЭМ` расшифровывается как Блок-Элемент-Модификатор. Смысл этих терминов раскрыт ниже.

Объектно-ориентированное программирование - парадигма, применимая во многих языках. ООП является одним из самых распространённых примеров методологии в программировании.

Сходно с ООП, методология
БЭМ – это и набор паттернов, и способ описывать действительность при помощи кода и размышлять о
сущностях вне зависимости от того, на каком языке программирования реализуется проект.

На основе этой методологии разработаны подходы к вёрстке и технические решения,
которые позволяют быстро создавать новые страницы и легко поддерживать уже
существующие.

### Единая предметная область
Представьте себе обычный сайт. Например, такой, как на картинке.

![Обычный сайт](//img-fotki.yandex.ru/get/9347/221798411.0/0_babd8_4e505a88_XXL.png)

При разработке и развитии сайта удобно мысленно выделять «блоки», из которых сайт состоит.

Например, на этом макете есть `Шапка`, `Основной лайаут` и `Подвал`. Шапка в свою
очередь состоит из `Логотипа`, `Поиска`, `Блока авторизации` и `Меню`. Основной
лайаут содержит `Заголовок страницы` и `Блок текста`.

![Блоки сайта](//img-fotki.yandex.ru/get/9258/221798411.0/0_babd7_c4c0b5d6_XXL.png)

Если для каждой составляющей страницы определено название, этими терминами удобно пользоваться при общении
внутри команды.

Менеджер может попросить
 * увеличить `Шапку`, или
 * сделать ещё одну страницу, где в `Шапке` нет `Поиска`.

Можно попросить JavaScript-разработчика
 * сделать `Блок авторизации` анимированным, или
 * выводить подсказку к `Поиску` быстрее.

Таким образом, **блоком** мы называем некоторую самостоятельную сущность, кирпичик проекта.

**Пример**  
Блок формы поиска

![Блок поисковой формы](//img-fotki.yandex.ru/get/9316/221798411.0/0_babd5_c3d7b2b5_XL.png)

Блок может быть простым или составным, то есть содержать в себе другие блоки.

**Элемент** – это часть блока, отвечающая за отдельную функцию.
Он может находиться только в составе блока и не имеет смысла в отрыве от него.

**Пример**  
Поле ввода и кнопка — элементы поискового блока

![Поле ввода и кнопка](//img-fotki.yandex.ru/get/9515/221798411.0/0_babd4_efd80a69_XXL.png)

### Cредства описания страницы и шаблоны
Блоки и элементы – это определение содержания страницы. Помимо самого факта наличия
конкретных блоков на странице, важно также их расположение.

Блоки (или элементы) могут следовать друг за другом в определённом порядке.

Например, товары в интернет-магазине:

![Товары в интернет-магазине](//img-fotki.yandex.ru/get/9109/221798411.0/0_babcc_d935a8ec_XXL.png)

Или пункты меню:

![Пункты меню](//img-fotki.yandex.ru/get/6726/221798411.0/0_babd1_f14000fa_XL.png)

Блоки могут быть вложены друг в друга.

Например, блок `Шапка` содержит другие блоки:

![Составляющие блока Шапка](//img-fotki.yandex.ru/get/5008/221798411.0/0_babce_7deef28f_XXL.png)

Для того, чтобы быстро изменять содержание страницы, добавлять новые блоки, перемещать их друг
относительно друга, нужен способ описания страницы в виде текста. Для этого необходимо,
чтобы каждому блоку или элементу соответствовало ключевое слово.

Ключевое слово, обозначающее конкретный блок, называется `именем блока`.  
Например, `menu` для меню или `head` для шапки сайта.

Ключевое слово, обозначающее элемент, называется `именем элемента`.  
Например, каждый пункт меню – это элемент `item` блока `menu`.

Имя блока должно быть уникальным и однозначно указывать, о каком блоке идёт речь.
Одинаковые имена могут быть только у одинаковых блоков. В этом случае мы говорим о том,
что один блок представлен на странице два или более раз.

Имя элемента должно быть уникальным только в пределах блока.
Элемент может повторяться в блоке несколько раз.

Например, пункты меню:

![Пункты меню](//img-fotki.yandex.ru/get/6726/221798411.0/0_babd1_f14000fa_XL.png)

Такие ключевые слова нужно размещать в определённом порядке. Для этого подойдут форматы
данных с использованием вложенности. Например, XML или JSON:

```xml
<b:page>
  <b:head>
    <b:menu>
      …
    </b:menu>
    <e:column>
      <b:logo/>
    </e:column>
    <e:column>
      <b:search>
        <e:input/>
        <e:button>Search</e:button>
      </b:search>
    </e:column>
    <e:column>
      <b:auth>
        …
      </b:auth>
    </e:column>
  </b:head>
</b:page>
```

В данном примере пространства имён `b` и `e` использованы, чтобы отделять узлы блоков от узлов элементов.

То же самое в JSON:

```js
{
  block: 'page',
  content: {
    block: 'head',
    content: [
      { block: 'menu', content: … },
      {
        elem: 'column',
        content: { block: 'logo' }
      },
      {
        elem: 'column',
        content: [
          {
            block: 'search',
            content: [
              { elem: 'input' },
              { elem: 'button', content: 'Search' }
            ]
          }
        ]
      },
      {
        elem: 'column',
        content: {
          block: 'auth', content: …
        }
      }
    ]
  }
}
```

На примерах выше приведена объектная модель с вложенностью блоков и элементов в другие
блоки. Также в описании страницы присутствуют произвольные данные.

Такую структуру мы называем `БЭМ-деревом` (по аналогии с DOM-деревом).

Конечный HTML для браузера получается из БЭМ-дерева страницы путём наложения шаблонов
(например, XSL-шаблоны или JavaScript).

Если разработчику нужно переместить блок в другое место на странице, это делается при
помощи изменения дерева. Конечный вид страницы определяется шаблоном.

Вы можете использовать любой формат описания БЭМ-дерева и любой шаблонизатор.

Мы ориентируемся на JSON как на формат описания страницы.
На его основе, при помощи JavaScript-based шаблонизатора BEMHTML, в последствии создаётся HTML-разметка.

### Независимость блоков
Во время разработки или поддержки долгосрочного проекта может возникнуть желание
переместить блок. Например, стоит задача

 * поменять местами `Логотип` и `Блок авторизации`, или
 * разместить `Меню` под `Поиском`.

![Смена положения блоков](//img-fotki.yandex.ru/get/9110/221798411.0/0_babcf_819f07f2_XXL.png)

![Смена положения блоков](//img-fotki.yandex.ru/get/9153/221798411.0/0_babcd_313420f0_XXL.png)

Для того, чтобы эти задачи легко решались, блоки должны быть `независимыми`.

`Независимый` блок реализован так, чтобы его можно было вставить в любое место на странице, в том числе и в другой блок.

#### Независимый CSS
С точки зрения CSS блока это означает, что

 * у блока (или элемента) должно быть уникальное «имя», для которого можно написать CSS-правило (например, соответствующий CSS-класс);
 * не должно быть задано CSS-селекторов на теги (`.menu td`), они по определению контекстно-зависимы;
 * необходимо избегать использования каскадных селекторов.

##### Пример схемы именования независимых CSS-классов
Одна из возможных схем именования CSS-классов, удовлетворяющая требованиям, такая:

 * CSS-класс блока совпадает с `именем блока`.

```xml
<ul class="menu">
  …
</ul>
```
 * CSS-класс элемента — это `имя блока` и `имя элемента`, разделённые
 определённым символом (или символами).

```xml
<ul class="menu">
  <li class="menu__item">…</li>
  <li class="menu__item">…</li>
</ul>
```

Учитывать имя блока в CSS-классе для элемента необходимо для минимизации каскада.

Также, важно использовать одинаковые разделители - для облегчения написания инструментов программного доступа к элементам.

Мы используем дефис для разделения слов в длинных именах (например, `block-name`) и два
подчёркивания для отделения имени блока от имени элемента (`block-name__element-name`), но вы можете выбрать другую схему.

Например:
  * `block-name--element-name`, или
  * `blockName-elementName`

####Независимые шаблоны
С точки зрения шаблонного движка независимость блоков означает, что

  * блок может быть легко помещён в любое место в БЭМ-дереве;
  * блоки и элементы должны иметь описание во входных данных. Имя блока (или элемента) должно быть уникальным, чтобы при передаче данных шаблонному движку можно было объявить: «Здесь нужно разместить `Меню`».

##### Пример независимых шаблонов для блоков
Встречая во входных данных описание блока, шаблон должен однозначно преобразовывать его в нужный HTML, поэтому каждому блоку должен соответствовать отдельный шаблон.

Например, в XSL это может выглядеть так:

```xml
<xsl:template match="b:menu">
  <ul class="menu">
    <xsl:apply-templates/>
  </ul>
</xsl:template>

<xsl:template match="b:menu/e:item">
  <li class="menu__item">
    <xsl:apply-templates/>
  </li>
<xsl:template>
```

В своих разработках мы постепенно отказываемся от XSL в пользу собственного
JavaScript-based шаблонного движка [XJST](https://ru.bem.info/tools/templating-engines/xjst/). Этот шаблонизатор вобрал в
себя всё то, что нам нравилось в XSL, но реализует это с производительностью JavaScript как на
сервере, так и на клиенте.

Мы пишем шаблоны для блоков на предметно-ориентированном языке (domain specific language) BEMHTML, в основе которого лежит XJST.

[Основные понятия шаблонизатора BEMHTML](https://ru.bem.info/technology/bemhtml/current/rationale/).

### Повторяемость блоков
На странице могут появиться

 * два блока `Текст`, разделенных рекламной вставкой, или
 * второй блок `Меню`: например, в `Подвале`.

Даже если блок проектировался как единственный, на странице в любой момент может понадобиться наличие его копии.

**С точки зрения CSS**, это означает, что вместо селекторов с ID удобнее использовать классы.

**С точки зрения JavaScript**, это означает, что блоки, которым свойственно одинаковое поведение, могут быть однозначно определены: у них одинаковый CSS-класс. Используя селекторы класса, можно выбрать все одинаковые блоки на странице и задать им нужное динамическое поведение.

### Модифицируемость блоков
Может возникнуть ситуация, в которой требуется не просто повторить блок, но и внести в него
незначительные изменения.

Например, стоит задача:
 * Сделать в подвале ещё одно меню, с *другим дизайном*.

![Добавить меню в подвале](//img-fotki.yandex.ru/get/9255/221798411.0/0_babd6_ec71b7f8_XXL.png)

Чтобы не разрабатывать новый блок, минимально отличающийся от уже существующего,
нужно воспользоваться `модификатором`.

`Модификатор` — это свойство блока или элемента, которое меняет его внешний вид или поведение.

Модификатор имеет имя и значение. Одновременно может использоваться несколько разных модификаторов.

**Пример**  
Модификатор блока задаёт ему цвет фона

![Смена фона блока](//img-fotki.yandex.ru/get/9325/221798411.0/0_babd2_7da50c7b_XL.png)

**Пример**  
Модификатор элемента для текущего пункта меню изменяет его внешний вид

![Смена внешнего вида блока](//img-fotki.yandex.ru/get/9313/221798411.0/0_babd0_503ecad_L.png)

**С точки зрения входных данных**, в БЭМ-дереве модификаторы представлены как свойства той сущности, которая описывает блок или элемент.

Например, в XML это могут быть атрибуты соответствующего узла:

```xml
<b:menu m:size="big" m:type="buttons">
  …
</b:menu>
```

То же самое в формате JSON:

```js
{
  block: 'menu',
  mods: [
    { size: 'big' },
    { type: 'buttons' }
  ]
}
```

**C точки зрения HTML/CSS**, модификатор представлен дополнительным CSS-классом блока или элемента.

```xml
<ul class="menu menu_size_big menu_type_buttons">
  …
</ul>
```

```css
.menu_size_big {
  // CSS code to specify height
}
.menu_type_buttons .menu__item {
  // CSS code to change item's look
}
```

Мы используем одно подчёркивание для отделение имени модификатора от имени блока и ещё одно подчёркивание для отделения значения модификатора от его имени.

### Модифицируемость элементов
Модифицируемость элементов реализуется аналогично.

**NB**: При написании CSS важно использовать одинаковые разделители имени
элемента и имени блока - для удобного оперирования ими в инструментах программного доступа и JavaScript-функциях.

Например, модификатором можно обозначить текущий пункт меню:

```xml
<b:menu>
  <e:item>Index<e:item>
  <e:item m:state="current">Products</e:item>
  <e:item>Contact<e:item>
</b:menu>
```

```js
{
  block: 'menu',
  content: [
    { elem: 'item', content: 'Index' },
    {
      elem: 'item',
      mods: { 'state' : 'current' },
      content: 'Products'
    },
    { elem: 'item', content: 'Contact' }
  ]
}
```

```css
.menu__item_state_current
{
  font-weight: bold;
}
```

Что может быть представлено в HTML так:

```html
<ul class="menu">
  <li class="menu__item">Index</li>
  <li class="menu__item menu__item_state_current">Products</li>
  <li class="menu__item">Contact</li>
</ul>
```

Или так, чтобы сделать классы меню независимыми от деталей реализации его раскладки:

```html
<div class="menu">
  <ul class="menu__layout">
    <li class="menu__layout-unit">
      <div class="menu__item">Index</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item menu__item_state_current">Products</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item">Contact</div>
    </li>
  </ul>
</div>
```

```html
<div class="menu">
  <table class="menu__layout">
  <tr>
    <td class="menu__layout-unit">
      <div class="menu__item">Index</div>
    </td>
    <td class="menu__layout-unit">
      <div class="menu__item menu__item_state_current">Products</div>
    </td>
    <td class="menu__layout-unit">
      <div class="menu__item">Contact</div>
    </td>
  </tr>
  </table>
</div>
```

### Предметная абстракция
Если над проектом работает много людей, им нужно договариваться о предметной области. В коде проекта у всех блоков должны быть однозначные имена.

Например, реализованный на сайте блок `Облако тегов` всегда называется `tags`, а каждый элемент
(метка) в нём - `tag`. Это справедливо для любой технологии: CSS, JS, XSL и т.д.

**С точки зрения процесса разработки**, все участники процесса оперируют одними терминами.

**С точки зрения CSS**, стили блоков и элементов можно описывать на псевдоязыке, который затем компилируется в чистый CSS согласно принятой схеме именования.

```css
.menu {
  __layout {
    display: inline;
  }
  __layout-item {
    display: inline-block;
    …
  }
  __item {
    _state_current {
      font-weight: bold;
    }
  }
}
```

**С точки зрения JavaScript**, не нужно обращаться к DOM-узлам блоков и элементов по имени класса:

```js
$('menu__item').click( … );
$('menu__item').addClass('menu__item_state_current');
$('menu').toggle('menu_size_big').toggle('menu_size_small');
```

Схема именования CSS-классов для блоков и элементов может измениться. При использовании специальных
JavaScript-функций, для обращения к блокам и работы с их модификаторами нужно будет внести изменения
только в эти функции.

```js
block('menu').elem('item').click( … );
block('menu').elem('item').setMod('state', 'current');
block('menu').toggleMod('size', 'big', 'small');
```

Приведённый здесь код - абстрактный. В реальных разработках мы используем JavaScript-ядро блока
[i-bem](http://ru.bem.info/technology/i-bem/current/i-bem-js/) из библиотеки [bem-bl](http://ru.bem.info/libs/bem-bl/dev/).

### Консистентность блока
На нашем сайте реализован блок `Кнопка`, для которого задано динамическое поведение.

![Кнопка](//img-fotki.yandex.ru/get/6728/221798411.0/0_babcb_d1c8832d_M.png)

При наведении курсора на этот блок, он меняет свой внешний вид.

![Кнопка при наведении](//img-fotki.yandex.ru/get/9110/221798411.0/0_babca_47ce403c_M.png)

Менеджер может попросить использовать такую же кнопку на другой странице.

Простой CSS-реализации блока при этом не достаточно. Чтобы полностью воспроизвести блок,
нужно повторить и его поведение, описанное в JavaScript.

Таким образом, блок должен знать о себе всё: реализация блока подразумевает описание его
внешнего вида и поведения во всех необходимых технологиях. Этот принцип мы называем `мультилингвальностью`.

`Мультилингвальность` - это описание блока на всех языках (технологиях), необходимых для его работы.

Если блок нужно представить на странице, для него должны быть реализованы следующие технологии:
 * Шаблоны (XSL, TT2, JavaScript и т.д.), превращающие декларацию блока на странице в HTML-код;
 * CSS, отвечающий за внешний вид блока;
 * JavaScript-реализация блока, если у блока также есть динамическое поведение;
 * Картинки, относящиеся к блоку;
 * Документация к блоку.

В список технологий входит всё, что относится к блоку.

### Примеры из реальной жизни
Наиболее широко методологию БЭМ применяет в своих frontend-разработках компания [Яндекс](https://company.yandex.ru).

БЭМ-методология не требует применения определённого фреймворка. Также, не обязательно
применять методологию для всех web-технологий, используемых для построения страницы (хотя
это было бы наиболее эффективным решением).

[Все сервисы Яндекса](https://www.yandex.ru/all) применяют методологию БЭМ в своём
CSS и JavaScript-коде и XSL-шаблонах страниц. Например,
 * [Яндекс.Карты](https://maps.yandex.ru/?text=%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D1%8F%2C%20%D0%9C%D0%BE%D1%81%D0%BA%D0%B2%D0%B0&sll=37.609218%2C55.753559&ll=37.609218%2C55.753563&spn=2.570801%2C0.884460&z=9&l=map)
 * [Яндекс.Картинки](https://images.yandex.ru/yandsearch?text=Yandex+office&rpt=image)
 * [Яндекс.Видео](https://video.yandex.ru/#search?text=yac%202011)
 * [Яндекс.Авто](https://auto.yandex.ru/)
 * [Яндекс в Турции](https://www.yandex.com.tr/)

Некоторые сервисы вместо XSL-шаблонов используют упомянутые в статье BEMHTML-шаблоны:
 * [Поиск Яндекса](https://yandex.ru/yandsearch?text=BEM+methodology+front-end&lr=213)  
 * [Поиск на английском](https://yandex.com/yandsearch?text=%22What+is+BEM%3F%22+front-end&lr=213)
 * [Поиск по мобильным приложениям](http://apps.yandex.ru/)  

Другие российские порталы также используют БЭМ.

Например, сервисы [Mail.ru](http://mail.ru/) частично реализованы с применением БЭМ.
Это касается CSS-реализации страниц, а также собственного C++ шаблонизатора компании.

Другие примеры:
 * [Рамблер.Новости](http://beta.news.rambler.ru/)
 * [HeadHunter](http://hh.ru/)
 * [TNK Racing Team](http://futurecolors.ru/tnkracing/)

Сайты, разработанные на основе библиотеки [bem-bl](https://ru.bem.info/libs/bem-bl/):
 * [Mikhail Troshev vCard](http://mishanga.pro/)  
    Код проекта на GitHub: <https://github.com/mishanga/bem-vcard>
