## История создания БЭМ
Однажды, в далёкой-далёкой стране, компания [Яндекс](http://company.yandex.ru/) начала разрабатывать поиск по Интернету и сопутствующие сервисы.
Время шло, сервисы развивались и всё больше разработчиков интерфейсов вкладывали свои усилия в развитие Яндекса.

Они делали отличные сервисы и инструменты, облегчающие им жизнь, и вот пришло время поделиться этими наработками с комьюнити и помочь другим разработчикам сделать их работу проще.

Вы прочитаете о том, как разработчики интерфейсов Яндекса постоянно пересматривали и улучшали методы создания веб-страниц.
Разработчики интерфейсов отличаются своей огромной - зачастую инновационной - любознательностью и своей ленью, мотивирующей их на создание сложных систем, предназначенных для того, чтобы экономить время разработчика, унифицировать и автоматизировать процессы.

Для начала, давайте отмотаем время назад, в 2005 год, и заглянем через плечо ужасно занятого разработчика Яндекса...

### …как всё начиналось
В 2005 году фокус был в основном на серверной части сервисов. С точки зрения интерфейса, типичный проект Яндекса был набором статических HTML-страниц, которые использовались как основа для создания шаблонов на XSL.

Эти HTML-странички хранились в отдельной директории примерно в такой структуре:

```
about.html
index.html
…
project.css
project.js
i/
  yandex.png
```

Для каждой страницы создавался отдельный HTML-файл. Стили для них складывались в один файл на весь проект — `project.css`, скрипты — в `project.js`.

В то время JavaScript использовался как вспомогательный инструмент для оживления страницы и всё помещалось в небольшой файл.

Картинки складывались в отдельную директорию, их было много. В те времена ещё требовалась поддержка IE 5 и не было поддержки CSS3 в браузерах, картинки использовались для реализации любого оформления - даже для закруглённых уголков. :-)

Все стили находились в одном файле, и для отделения стилей разных частей страницы использовались комментарии с указанием начала и конца:

```css
/* Content container (begin) */
    #body
    {
        font: 0.8em Arial, sans-serif;

        margin: 0.5em 1.95% 0.5em 2%;
    }
/* Content container (end) */

/* Graphical banner (begin) */
    .banner
    {
        text-align: center;
    }

    .banner a
    {
        text-decoration: none;
    }
/* Graphical banner (end) */
```

В вёрстке использовались как `id`, так и `классы`.

Свёрстанные статические HTML-странички нарезались в XSL-шаблоны, которые использовались в продакшне. Если HTML изменялся, все правки вручную переносились в XSL. И наоборот: изменения в шаблонах несли за собой изменения в HTML - для поддержания статического HTML в актуальном состоянии.

Это было сложно, и даже когда это не было сложно — это было тупо.

### Проекты побольше
При вёрстке первой версии Яндекс.Музыки в начале 2006 года стало понятно,
что для проекта с большим количеством разных страниц этот подход работает плохо.

Тяжело подбирать названия классам, сложно держать в голове код всего проекта
и писать так, чтобы изменения на одной странице ничего не ломали на другой.

Типичный код того времени:

```css
/* Albums (begin) */
    .result .albums .info
    {
        padding-right: 8.5em;
    }

    .result .albums .title
    {
        float: left;
        padding-bottom: 0.3em;
    }

    .result .albums .album .listen
    {
        float: left;
        padding: 0.3em 1em 0 1em;
    }

    .result .albums .album .buy
    {
        float: left;
        padding: 0.4em 1em 0 1.6em;
    }

    .result .albums .info i
    {
        font-size: 85%;
    }
/* Albums (end) */
```

Здесь используется длинный каскад.

Ещё пример:

```css
/* Картинки на фоне (begin) */
    #foot div
    {
        height: 71px;
        background: transparent url(../i/foot-1.png) 4% 50% no-repeat;
    }

    #foot div div
    {
        background-position: 21%;
        background-image: url(../i/foot-2.png);
    }

    #foot div div div
    {
        background-position: 38%;
        background-image: url(../i/foot-3.png);
    }

    #foot div div div div
    {
        background-position: 54%;
        background-image: url(../i/foot-4.png);
    }

    #foot div div div div div
    {
        background-position: 71%;
        background-image: url(../i/foot-5.png);
    }

    #foot div div div div div div
    {
        background-position: 87%;
        background-image: url(../i/foot-6.png);
    }
/* Картинки на фоне (end) */
```

Здесь используются `id` и `теги`.

Одновременно с Музыкой началась вёрстка Я.ру.

Это был проект с десятками страниц, где подобный подход не сработал бы — вёрстка стала бы неуправляемой.

#### Появление блоков
Нам необходимо было определить предметную область для управления объектами интерфейса страницы. Это был вопрос методологии – нужно было внести больше ясности в то, как мы работаем с такими понятиями, как `класс`, `тег`, `визуальный компонент` и др.

Раньше для создания типичных страниц всё основное время и усилия разработчиков Яндекса тратилось на создание HTML-структуры страницы и написание CSS-стилей для неё. JavaScript воспринимался лишь как сопутствующая технология.

Чтобы облегчить поддержку HTML/CSS различных компонентов, был введен новый термин – `block`.

`Блок` – это часть дизайна страницы или раскладки со своим специфическим и уникальным значением, определенным семантически или визуально.

В большинстве случаев любой элемент на странице (сложный или простой) можно рассматривать как блок, HTML-контейнер которого получает уникальный CSS-класс с тем же именем, что и у блока.

Классы блоков получили префиксы (`b-`, `c-`, `g-`), чтобы отличать их от внутренних классов.

Используемые префиксы, с которых мы начинали:
 * **b-** block  
   Независимый блок, может использоваться в любом месте страницы.
 * **с-** control  
   Контрол (независимый блок), с которым ассоциирован JavaScript-объект, обеспечивающий его
   функциональность. Может использоваться в любом месте страницы.
 * **g-** global  
   Глобальное определение, используется по необходимости. Количество сведено к минимуму.

Кроме префиксов были постфиксы:
 * **-nojs** no javascript  
   Стиль применяется в отсутствие JavaScript. Если JavaScript включен, то при загрузке страницы
   вызывается метод `init()` в onload для удаления этого постфикса из всех классов на странице,
   что «включает» JavaScript для этих блоков.

#### Появление элементов
#### Что внутри?
В HTML-контейнере, формирующем блок, некоторые узлы получают четкое имя CSS-класса. Это не только облегчает создание стилистических правил, независящих от имени тега, но и присваивает семантически значимую роль каждому узлу. Такие внутренние узлы называются `элементами блока`, или просто `элементами`.  

Ключевое различие между блоком и элементом заключается в том, что элемент не может существовать вне контекста родительского блока. Так же как и из блока не может быть извлечен ни один элемент. Если элемент становится способным существовать вне блока, его необходимо рассматривать как блок. 

В самом начале элемент мог быть определен только внутри контейнера его родительского блока. Позже стало возможным вынимать некоторые элементы из блока, сохраняя при этом рабочее состояние блока.

Элементы, у которых много кода, выделялись комментариями.

```css
/* Head (begin) */
    .b-head { … }

    /* Logo (begin) */
        .b-head .logo { … }
        .b-head .logo a { … }
    /* Logo (end) */

    /* Right side (begin) */
    .b-head .right { … }

        /* Info (begin) */
            .b-head .info { … }
            .b-head .info .exit a { … }
        /* Info (end) */

        /* Search (begin) */
            .b-head .search { … }
            .b-head .search div div, .b-head .search div div i { … }
        /* Search (end) */
    /* Right side (end) */
/* Head (end) */
```

#### Структура вёрстки проекта
В Яндексе разработчики интерфейсов обычно поддерживают несколько проектов одновременно.

Переключение между разными репозиториями и ветками в них легче, если все проекты имеют
одинаковую (или очень похожую) файловую структуру.

Степень детализации – это еще одно требование, которое обеспечивает гибкость контроля версий и помогает избежать конфликтов во время ведения параллельной разработки.

Это привело нас к унификации структуры репозитория разных проектов.

CSS, JavaScript и картинки мы начали складывать в отдельные директории.

JavaScript применялся всё чаще, начали подключаться дополнительные компоненты и библиотеки.

Типичная структура вёрстки проекта:

```
index.html
css/
  yaru.css
  yaru-ie.css
js/
  yaru.js
i/
  yandex.png
```

Валидные хаки для IE писали в основном CSS-файле `yaru.css`.

```css
    /* Common definitions (begin) */
        body
        {
            font: 0.8em Arial, sans-serif;

            padding: 0 0 2em 0;
            background: #fff;
        }

        * html body
        {
            font-size: 80%;
        }
```

Невалидные — в файле `yaru-ie.css`.

```css
    /* Common blocks (begin) */
        /* Artist (begin) */
            .b-artist .i i
            {
                top: expression(7 + (90 - this.parentNode.getElementsByTagName('img')[0].height)/2);
                filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='../i/sticker-lt.png', sizingMethod='crop');
            }
```

### Зачатки общепортального фреймворка
При верстке нескольких проектов с похожим дизайном обязательно существуют общие блоки.

Портал Яндекса содержит сейчас больше 100 разных сервисов, выполненных в одном стиле, а для такого объема данных бездумный copy/paste с проекта
на проект уже не работает.

Так появилось общее хранилище повторно используемых компонентов, которое называлось `общая библиотека
блоков` или просто `Common`.

Первые блоки, которые были туда вынесены: шапка, подвал и стили для статического текста.

Соответствующие файлы хранились на выделенном внутреннем сервере разработчиков (**common.cloudkill.yandex.ru** в примере ниже).

Это было началом работы нашего общепортального фреймворка.

Cтили из него подключались в основной проектный файл при помощи импортов непосредственно с сервера:

```css
@import url(http://common.cloudkill.yandex.ru/css/global.css);
@import url(http://common.cloudkill.yandex.ru/css/head/common.css);
@import url(http://common.cloudkill.yandex.ru/css/static-text.css);
@import url(http://common.cloudkill.yandex.ru/css/foot/common-absolute.css);
@import url(http://common.cloudkill.yandex.ru/css/foot/common-absolute-4-columns.css);
@import url(http://common.cloudkill.yandex.ru/css/list/hlist.css);
@import url(http://common.cloudkill.yandex.ru/css/list/hlist-middot.css);
@import url(http://common.cloudkill.yandex.ru/css/dropdown/dropdown.css);
@import url(http://common.cloudkill.yandex.ru/css/dropdown/dropdown-arrow.css);
@import url(slider.css);

/* Header (begin) */
    /* Service (begin) */
        .b-head .service h1 { … }
        .b-head .service h1, .b-head .service h1 a, .b-head .service h1 b { … }
```

Слишком много импортов - страница загружается медленно. Было принято решение прекомпилировать стили (и позже JS-файлы)
перед выкладкой в продакшн.

Компиляция заменяет `@import` на содержимое внешних файлов (это называется `inlining`) и оптимизирует код:
например, убирает ненужные браузеру пробелы и комментарии.

Наш внутренний инструмент вырос из простого Perl-скрипта в отдельный open-source проект [borschik](http://ru.bem.info/tools/optimizers/borschik/).
Опробуйте его в своём проекте!

### Вёрстка независимыми блоками
К осени 2007 года правила вёрстки уже устоялись, и о них захотелось рассказать вне Яндекса.

На ClientSide'07 был сделан доклад про
[вёрстку независимыми блоками](http://vitaly.harisov.name/article/independent-blocks.html),
которая на тот момент составляла основу наших HTML-страниц.

В докладе вводится понятие `блок`:

<blockquote>Блоком будем называть фрагмент страницы, который описывается своей разметкой и стилями.</blockquote>

Более позднее [описание в клубе БЭМ](http://clubs.ya.ru/bem/replies.xml?item_no=42).

#### Правила блоков
Формулируются правила независимости блока:
  1. Для описания элемента используется `class`, но не `id`;
  2. Каждый блок имеет префикс;
  3. В таблице стилей нет классов вне блоков.

Отказ от `id` даёт возможность отображать на странице один и тот же блок несколько раз, а также позволяет использовать на одном DOM-узле несколько классов, что нам пригодилось в дальнейшем.

##### Простые и составные блоки
Блоки делятся на простые и составные.

<blockquote>В простые блоки нельзя вкладывать другие блоки, в составные — можно.</blockquote>

Это было очень наивное деление: мы неоднократно сталкивались с тем, что даже в самые простые блоки
вкладывались другие, и приходилось переделывать вёрстку.

Такая классификация фактически мешала нам во многих случаях, и в итоге мы пришли к противоположному принципу:

<blockquote>Любой блок должен позволять вкладывать в него другой блок, когда это возможно.</blockquote>

##### Правила полной независимости блоков
CSS не может считаться пуленепробиваемым, если на одной странице смешиваются стили из разных источников.

В сложных случаях блоки могут вредить отображению друг друга из-за конфликта имён элементов.
Стили, опирающиеся на имена тегов, могут охватывать больше элементов, чем было задумано.

Намучавшись с подобными ошибками, мы сформулировали правила более строгой независимости блоков,
которые назвали [абсолютно-независимыми блоками](http://clubs.ya.ru/bem/replies.xml?item_no=43) (АНБ):

  1. Никогда не опираться на элементы - только на классы.  
    `.b-user b -> .b-user .first-letter`
  2. Всем классам внутри блока давать имена, начинающиеся с имени этого блока.  
    `.b-user .first-letter -> .b-user-first_letter`

Наличие класса у каждого DOM-узла существенно увеличивает объем HTML-кода.

На тот момент мы считали, что это дорого, и применяли такой подход в исключительных случаях.

##### Префиксы
Как все знают, одна из самых сложных проблем в программировании — подбор имён переменным. :-)

Подробно изучив проблему, мы решили, что будем задавать для блоков разные префиксы, каждый со своей семантикой:

  * **b-** — обычные блоки;
  * **h-** — обёртки для нескольких блоков;
  * **l-** — раскладки;
  * **g-** — глобальные стили.

##### Модификация
Модификация может быть определена как особое состояние блока или как метка, несущая определённое свойство.

К примеру, блок `Кнопка` может иметь три состояния: маленькая, нормальная и большая.

Вместо того, чтобы создавать три разных блока, делается модификация одного. Она состоит из имени (например, `size`)
и значения (`small`, `normal` или `big`).

Существуют два варианта модификации:
  1. Блок может изменить свой внешний вид в зависимости от того, где он находится.  
     Это модификация от контекста.
  2. Можно добавить блоку второй класс. Это модификация постфиксом, она не зависит от контекста.  
     `class="b-block b-block-postfix"`

### Общепортальный фреймворк
Весной 2008 года была поставлена задача создать брендбук, описывающий наш портальный стиль.

Обычное описание подобных технологий устаревает ещё до того, как его успевают довести до конца. Было решено начать работу с того, что авторы проекта умели лучше всего, — написания HTML/CSS кода.

Проект получил название `Лего`.

#### Структура репозитория Лего
На верхнем уровне репозитория осуществлено первичное разделение - по технологиям.

```
css/
html/
js/
xml/
xsl/
```

У каждой папки технологии своя структура.

CSS распределяется в три разные директории:

```
css/
  block/
    b-dropdown/
      b-dropdown.css
  service/
    auto/
      block/
        b-head-logo-auto.css
      head.css
  util/
    b-hmenu/
      b-hmenu.css
```

 1. `block` — общепортальные блоки;
 2. `util` — блоки, которые имеют смысл вне Яндекса, их можно выложить в open source;
 3. `service` — стили для конкретных сервисов Яндекса. Подключив их к сервису, можно отобразить шапку или подвал.

Структура директории HTML аналогична CSS.

```
html/
  block/
    b-dropdown.html
  service/
    auto/
      l-head.html
  util/
    b-hmenu.html
```

JS находится в зачаточном состоянии:

```
js/
  check-is-frame.js
  check-session.js
  clean-on-focus.js
  dropdown.js
  event.add.js
  event.del.js
```

У каждого сервиса есть XML-файл, использующийся для построения шапки.

```
xml/
  block/
    b-head-tabs-communication.xml
    common-services.ru.xml
    head-messages.ru.xml
  service/
    auto/
      head.xml
```

XSL блоков лежит в одной директории:

```
xsl/
  block/
    b-dropdown.xsl
    b-head-line.xsl
    i-common.xsl
    i-locale.xsl
    l-foot.xsl
    l-head.xsl
```

Каждому блоку соответствует один файл.

`Лего` подключается на проекты через *svn:externals*.

При сборке для продакшна, код библиотеки полностью включается в проект,
что можно сравнить со статической линковкой.

Такой подход позволяет выпускать версии сервисов с разными версиями `Лего`
и переходить на новую версию тогда, когда это удобно команде проекта.

Мы используем его до сих пор.

##### Файлы страниц
Файлы, подключавшиеся на страницах, состояли из `@import`'ов реализации блоков.

```css
@import url(../../block/l-head/l-head.css);
@import url(../../block/b-head-logo/b-head-logo.css);
@import url(../../block/b-head-logo/b-head-logo_name.css);
@import url(block/b-head-logo-auto.css);
```

Эти  `@import`’ы писались вручную.

Именование файлов ещё не устоялось - мы пробуем разные варианты.

### Общепортальный фреймворк Лего 1.2 (2008)
Чуть позже, в рамках версии 1.2, был произведён рефакторинг, и структура `Лего` изменилась.

```
common/
  css/
  js/
  xml/
  xsl/
example/
  html/
service/
  auto/
    css/
    xml/
```

Убрано разделение на `util` и `block`, весь общий CSS лежит в `common/css`.

От идеи выноса кода в open source на тот момент отказались и вернулись к ней только через два года.

```
common/
  css/
    b-dropdown/
      arr/
        b-dropdown.arr.css
        b-dropdown.arr.ie.css
        b-dropdown.css
        b-dropdown.ie.css
```

Файлы для IE переименованы: было `-ie.css` - стало `.ie.css`.
Расширения файлов теперь могут состоять из нескольких слов.

Всё, что находилось в опциональном CSS (файлах `b-dropdown_arr.css`),
вынесено в директории (`arr/b-dropdown.arr.css`).

В основном файле блока стало меньше кода.

Для модификации постфиксом вместо дефиса начали использовать подчёркивание. Это позволило визуально отделить имя блока от имени модификатора, что
позже пригодилось при реализации инструментов, упрощающих работу с кодом.

### БЭМ
В марте 2009 года выходит версия `Лего 2.0`.

Этим событием оканчивается `вёрстка независимыми блоками` и начинается `БЭМ`.

БЭМ — аббревиатура от Блок-Элемент-Модификатор. Это три ключевых сущности, которые мы используем при разработке веб-компонентов.

#### Лего 2.0 (2009)
Что же принципиально изменилось с выходом версии 2.0?

Основное изменение — мы вывели вперёд блоки, а не технологии.
Отныне блоки первичны, а технологии их реализации — вторичны.

Реализацию каждого блока разместили в отдельной директории, технологии —
это файлы внутри неё. Также появилась документация к блоку — файл
`.wiki` внутри блока.

Какими терминами мы тогда оперировали?

##### Терминология
**Независимый блок**, который может быть использован в любом месте страницы.

В XML он представлен тегом в неймспейсе `lego`:

```xml
<lego:l-head>
<lego:b-head-logo>
```

HTML-класс блока соответствует имени этого тега:

```xml
<table class="l-head">
<div class="b-head-logo">
```

CSS:

```css
.l-head
.b-head-logo
```

Все файлы (css, js, html, xsl), относящиеся к блоку, кладутся в его директорию:

```
common/
  block/
    b-head-logo/
      b-head-logo.css
      b-head-logo.xsl
      b-head-logo.js
      b-head-logo.wiki
```

Элементы в XML пишутся в неймспейсе `lego` без префикса:

```xml
<lego:b-head-logo>
    <lego:name/>
</lego:b-head-logo>
```

Класс в HTML — тоже без префикса.

```html
<div class="b-head-logo">
    <span class="name">Авто</span>
</div>

.b-head-logo .name { ... }
```

Файлы для вложенного элемента кладутся в отдельную директорию.

```
common/
  block/
    b-head-logo/
      name/
        b-head-logo.name.css
        b-head-logo.name.png
        b-head-logo.name.wiki
```

Модификаторы в XML представлены атрибутами в неймспейсе `lego`:

```xml
<lego:b-head-tabs lego:theme="grey">
```

В HTML используется дополнительный класс.

```xml
<div class="b-head-tabs b-head-tabs_grey">

.b-head-tabs_grey { ... }
```

Файлы для модификатора кладутся в отдельную директорию, с
подчёркиванием в начале имени:

```xml
common/
    block/
        b-head-logo/
            _theme/
                b-head-logo_gray.css
                b-head-logo_gray.png
                b-head-logo_gray.wiki
```

##### Декларация используемых блоков
Все лего-компоненты проекта описываются в XML-файле.

```xml
<lego:page>
    <lego:l-head>
        <lego:b-head-logo>
            <lego:name/>
        </lego:b-head-logo>

        <lego:b-head-tabs type="search-and-content"/>
```

Из него генерируются CSS-файлы.

```css
@import url(../../common/block/global/_type/global_reset.css);
@import url(../../common/block/l-head/l-head.css);
@import url(../../common/block/b-head-logo/b-head-logo.css);
@import url(../../common/block/b-head-logo/name/b-head-logo.name.css);
@import url(../../common/block/b-head-tabs/b-head-tabs.css);
@import url(../../common/block/b-dropdown/b-dropdown.css);
@import url(../../common/block/b-dropdown/text/b-dropdown.text.css);
@import url(../../common/block/b-pseudo-link/b-pseudo-link.css);
@import url(../../common/block/b-dropdown/arrow/b-dropdown.arrow.css);
@import url(../../common/block/b-head-search/b-head-search.css);
@import url(../../common/block/b-head-search/arrow/b-head-search.arrow.css);
@import url(../../common/block/b-search/b-search.css);
@import url(../../common/block/b-search/input/b-search.input.css);
@import url(../../common/block/b-search/sample/b-search.sample.css);
@import url(../../common/block/b-search/precise/b-search.precise.css);
@import url(../../common/block/b-search/button/b-search.button.css);
@import url(../../common/block/b-head-userinfo/b-head-userinfo.css);
@import url(../../common/block/b-head-userinfo/user/b-head-userinfo.user.css);
@import url(../../common/block/b-user/b-user.css);
@import url(../../common/block/b-head-userinfo/service/b-head-userinfo.service.css);
@import url(../../common/block/b-head-userinfo/setup/b-head-userinfo.setup.css);
@import url(../../common/block/b-head-userinfo/region/b-head-userinfo.region.css);
@import url(block/b-head-logo/b-head-logo.css);
@import url(block/b-head-search/b-head-search.css);
```

На примере этого файла видно, что сначала указывается общий код,
а потом добавляются стили, чтобы привести лего-блоки к дизайну проекта.

Имена файлов элементов пишутся через точку: `b-head-logo.name.css`

Из XML-декларации генерируются и JS-файлы.

```js
include("../../common/block/i-locale/i-locale.js");
include("../../common/block/b-dropdown/b-dropdown.js");
include("../../common/block/b-search/sample/b-search.sample.js");
include("../../common/block/b-head-userinfo/user/b-head-userinfo.user.js");
```

А также XSL-файлы.

```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:import href="../../common/block/i-common/i-common.xsl"/>
<xsl:import href="../../common/block/i-items/i-items.xsl"/>
<xsl:import href="../../common/block/l-head/l-head.xsl"/>
<xsl:import href="../../common/block/b-head-logo/b-head-logo.xsl"/>
<xsl:import href="../../common/block/b-head-logo/name/b-head-logo.name.xsl"/>
<xsl:import href="../../common/block/b-head-tabs/b-head-tabs.xsl"/>
<xsl:import href="../../common/block/b-dropdown/b-dropdown.xsl"/>
<xsl:import href="../../common/block/b-pseudo-link/b-pseudo-link.xsl"/>
<xsl:import href="../../common/block/b-head-search/b-head-search.xsl"/>
<xsl:import href="../../common/block/b-search/b-search.xsl"/>
<xsl:import href="../../common/block/b-search/input/b-search.input.xsl"/>
<xsl:import href="../../common/block/b-search/sample/b-search.sample.xsl"/>
<xsl:import href="../../common/block/b-search/precise/b-search.precise.xsl"/>
<xsl:import href="../../common/block/b-search/button/b-search.button.xsl"/>
<xsl:import href="../../common/block/b-head-userinfo/b-head-userinfo.xsl"/>
<xsl:import href="../../common/block/b-user/b-user.xsl"/>
<xsl:import href="../../common/block/b-head-userinfo/service/b-head-userinfo.service.xsl"/>
<xsl:import href="../../common/block/b-head-userinfo/setup/b-head-userinfo.setup.xsl"/>
<xsl:import href="../../common/block/b-head-userinfo/region/b-head-userinfo.region.xsl"/>

</xsl:stylesheet>
```

Мы перестали писать эти файлы руками, началась генерация кода.

#### Скорость селекторов (2009)
При реализации новой версии Яндекс.Почты была поставлена задача сделать её быстрой как компьютерная программа.

Для решения задачи мы начали использовать XSL в браузере (и
подгружать по сети XML, необходимый для отрисовки данных на странице)
и столкнулись с проблемой, что трансформации отрабатываются быстро,
но вставка в DOM полученного результата происходит очень медленно.
При этом, если отключить CSS, всё происходит быстро.

Исследуя проблему, мы пришли к тому, что тормозят селекторы
CSS, которые при большом DOM-дереве и большой таблице стилей оказывают
существенное влияние на скорость отрисовки браузером страницы.

Результаты исследования подробно описаны в [статье](http://clubs.ya.ru/bem/replies.xml?item_no=338).

Мы поняли, что решение этой проблемы у нас есть давно — это
[абсолютно-независимые блоки](http://clubs.ya.ru/bem/replies.xml?item_no=43).

Мы перевели все блоки в `Лего` на АНБ-нотацию и с тех пор пишем их так, чтобы
у каждого DOM-узла был свой `class`, на который можно навесить стили. Также мы не
используем Tag Rules в CSS.

В классы элементов вносится имя блока, селекторы получаются простыми и быстрыми.

```html
<div class="b-head-logo">
    <span class="b-head-logo__name">
        Авто
    </span>
</div>
```

#### Стабилизация нотации
Постепенно мы пришли к тому, что нотация в коде и структура на файловой
системе устоялись и уже не меняются.

В именах файлов разделитель . был заменён на __. Было `b-block.elem.css` —
стало `b-block__elem.css`. Теперь они совпадают с CSS-селекторами.

Были реализованы модификаторы у элементов по аналогии с модификаторами блоков:
`.b-block__elem_theme_green` по аналогии с `.b-block_theme_green`.

В имя файла модификатора и в его класс внесён тип модификатора.
Было `.b-menu__item_current` — стало `.b-menu__item_state_current`.

Причина этого изменения — работа с модификаторами из JS.

### Open Source (2010)
В 2010 году мы создали организацию [bem](https://github.com/bem) на GitHub,
чтобы вести разработку в open source.

#### Библиотека bem-bl
Мы начали выносить блоки из `Лего` в [bem-bl](http://ru.bem.info/libs/bem-bl/dev/),
проводя одновременно с этим рефакторинг.

Вместе с выносом блоков публиковали информацию про них в клубе:
[Блок, Элемент, Модификатор (БЭМ, BEM)](http://clubs.ya.ru/bem/posts.xml?tag=75173403).

Работы по выносу блоков в open source пока не закончены.

#### Инструменты
Началась реализация инструментов [bem-tools](http://ru.bem.info/tools/bem/bem-tools/),
которые помогают работать с файлами по БЭМ-методам.

Инструменты реализуются на JavaScript под Node.js.

Директории с реализацией блоков стали называть `уровнем переопределения`.

Например, на проекте может быть:

 1. Публичная библиотека блоков с GitHub;
 2. Внутренняя библиотека lego;
 3. Блоки самого проекта.

```
bem-bl/
  b-logo/
lego/
  b-logo/
auto/
  blocks/
    b-logo/
```

На уровне переопределения можно задать другую схему именования папок/файлов, отличную от нашей.

Для этого нужно сконфигурировать уровень:

```
.bem/
  level.js
```

К примеру, вы можете задать другие разделители между именем блока
и элемента, или не раскладывать всё по директориям, а предпочесть
плоскую структуру файлов.

#### Шаблонизатор BEMHTML
После экспериментов с разными шаблонизаторами, был разработан
шаблонизатор [BEMHTML](http://ru.bem.info/technology/bemhtml/current/intro/).

Этот шаблонизатор

 1. позволяет писать шаблоны в БЭМ-терминах;
 2. доопределять их на уровнях переопределения;
 3. исполнять эти шаблоны как на сервере, так и в браузере, поскольку
 шаблоны компилируются в простой и быстрый JavaScript.

О BEMHTML есть много информации в клубе на Яру:

 * <http://clubs.ya.ru/bem/replies.xml?item_no=898>
 * <http://clubs.ya.ru/bem/replies.xml?item_no=899>
 * <http://clubs.ya.ru/bem/replies.xml?item_no=1153>
 * <http://clubs.ya.ru/bem/replies.xml?item_no=1172>
 * <http://clubs.ya.ru/bem/replies.xml?item_no=1391>

### Резюме
Как вы можете видеть, БЭМ появился не сразу.
У нас был долгий период проб и подбора наиболее подходящего нам варианта.

Но обращаем ваше внимание, что всё это время это всё же был БЭМ.

То, что мы используем сейчас, — не единственно верное решение.
Наоборот, мы рекомендуем использовать БЭМ в ваших проектах в том объёме, в котором он принесёт наибольшую пользу.

Гибкость БЭМ-методологии позволяет вам настраивать её под свои текущие процессы.
Это способ организации работы над проектом, который позволяет команде работать c единым кодом и говорить на одном языке.

Каждая конкретная команда встраивает его в свой процесс разработки и использует так, как им удобно.

Например, у вас есть проект, в котором вы хотите применить БЭМ только для вёрстки.

Хорошо, мы тоже с этого начинали.

Выбирайте подходящую вам схему...

Например, с префиксами и каскадом.

```css
.b-block
.b-block .elem
.b-block_size_l
.b-block .elem_size_l
```

Или задайте класс каждому DOM-узлу и используйте абсолютно-независимые блоки.

```css
.b-block
.b-block__elem
.b-block_size_l
.b-block__elem_size_l
```

Или можно убрать префиксы.

```css
.block
.block__elem
.block_size_l
.block__elem_size_l
```

И начинайте делать вёрстку на проекте согласно БЭМ.

Об организации файловой системы [читайте отдельно](/method/filesystem/).
