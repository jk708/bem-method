## Представление блоков на файловой системе
БЭМ - очень гибкая методология, что позволяет вам настраивать её под свои процессы, под свои текущие технологии.

В ситуации, когда
  * проект живёт долго и постоянно обрастает новыми сущностями, и
  * команда разработки состоит из нескольких специалистов, растёт и изменяется (появляются новые люди),
  
необходимо уметь быстро определять, где может располагаться код определенного блока.

### Варианты именования файлов
#### Блоки в одном файле
Допустим, у вас есть проект, в котором вы хотите применить БЭМ для HTML/CSS вёрстки и ни для чего более.

В этом случае используйте самую простую схему, при которой реализация блоков описана в файлах с разделением по технологиям: HTML, CSS, JS.

```
myfacebook/
  myfacebook.css
  myfacebook.js
  myfacebook.html
```

Файлы `myfacebook.css` и `myfacebook.js` содержат весь CSS/JS код проекта и подключаются в HTML как есть, минуя процесс сборки и оптимизации кода.

Фактически, БЭМ применяется только для именования CSS-классов.

#### Блоки в разных файлах
В большом проекте, если весь CSS-код блоков содержится в одном файле, в нём становится сложно ориентироваться.

Логичнее размещать код каждого блока в отдельном файле, одноимённом имени блока:

```
blocks/
  head.css
  menu.css

all.css

index.html
about.html
```

В файле `all.css` можно указать `@import` соответствующих файлов из директории `blocks`:

``` css
@import url(blocks/head.css);
@import url(blocks/menu.css);
…
```

#### Элементы и модификаторы в отдельных файлах
Если в ваших блоках есть элементы/модификаторы, которые используются не на всех страницах,
удобно вынести их реализацию в отдельные файлы, чтобы подключать только то, что нужно в каждом конкретном случае.

При этом можно использовать такую схему расположения на файловой системе:

  * Основной код блока размещён в файлах `имя-блока`
    * Имя файла совпадает с именем блока
    * Техническая реализация блока размещена в файлах с соответствующими расширениями
  * Элементу соответствует файл `имя-блока__имя-элемента`
    * Имя файла совпадает с именем элемента
    * Техническая реализация элемента располагается в файлах с соответствующими расширениями
  * Модификатору соответствует файл `имя-блока_имя-модификатора_значение`
    * Имя файла содержит как имя модификатора, так и его значение
    * Техническая реализация модификатора размещается в файлах в той же директории

Вы можете использовать другую схему отделения имени блока от имени элемента и модификатора.

**Пример**

```
blocks/
  head.css
  head__search.css
  head_size_big.css
  menu.css

about.css
about.html

index.css
index.html
```

Файл `index.css` содержит увеличенную в размере шапку, но без поискового поля:

```css
@import url(blocks/head.css);
@import url(blocks/head_size_big.css);
@import url(blocks/menu.css);
…
```

A в файле `about.css` шапка обычного размера и есть поле поиска:

```css
@import url(blocks/head.css);
@import url(blocks/head__search.css);
@import url(blocks/menu.css);
…
```

В этом случае становится рационально использовать [bem-tools](http://ru.bem.info/tools/bem/bem-tools/) для сборки проекта.

#### Каждый блок в своей директории
Может потребоваться использовать несколько блоков из предыдущего проекта в новом проекте. Для этого нужно уметь копировать реализацию блока во всех технологиях: при помощи копирования непосредственно файлов или частичным чекаутом репозитория проекта-донора.

И в том, и в другом случае удобно, чтобы все файлы, относящиеся к блоку, располагались
в одной директории:

```
blocks/
  menu/
    menu.xsl
    menu.js
    menu.css
```

#### Элементы и модификаторы в отдельных директориях
В процессе работы над проектом может возникнуть необходимость изменить какой-нибудь блок.

Менеджер может попросить
  *  изменить цвет активного пункта `Меню`, или
  *  сделать `Меню` реагирующим на наведение курсора.

Один разработчик может попросить другого
  *  помочь с вёрсткой формы `Поиска` под IE.

Чтобы было легко найти нужный код, при разработке удобно следовать фиксированным требованиям:

  * Весь код блока размещён в отдельной директории
    * Имя директории совпадает с именем блока
    * Техническая реализация блока размещена в файлах в директории блока
  * Элементу соответствует поддиректория в директории блока
    * Имя директории совпадает с именем элемента
    * Техническая реализация элемента располагается в файлах в этой директории
  * Модификатору соответствует поддиректория в директории блока
   * Имя директории соответствует имени модификатора
   * Техническая реализация модификатора размещается в файлах в этой директории
   * Названия файлов содержат как имя, так и значение модификатора

Этот вариант позволяет наглядно просматривать структуру блока в файловой системе.

**Пример**  
Файловая структура блока `Меню`

```
menu/
  __item/
    _state/
      menu__item_state_current.css
      menu__item_state_current.xsl
    menu__item.css
    menu__item.xsl
  menu.css
  menu.js
  menu.xsl
```

Очевидно, что поддержка такой файловой структуры в ручном режиме неудобна. Для автоматизации процессов мы создали [bem-tools](http://ru.bem.info/tools/bem/bem-tools/) - пакет инструментов, который помогает создавать
и поддерживать файловую структуру, создавать файлы по шаблонам и т.д.

#### Группировка блоков в папки
На большом портале часто необходимо реализовывать одни и те же блоки в разных проектах.

Может возникнуть задача
  * реализовать одинаковый `Подвал` во всех проектах портала, или
  * создать новый проект, используя блоки уже существующего.

Конвейерная разработка сайтов в веб-студии часто подразумевает использование типовых решений для типовых страниц.

Менеджер может попросить
  * сделать страницу заказа товара с формой *как на позапрошлом проекте*.

Рациональнее выполнять эти задачи не копируя блоки: должен быть способ подключать их из одного проекта в другой. Для этого блоки полезно сгруппировать в одну директорию.

Мы называем такую директорию `blocks`.

**Пример**

```
blocks/
  foot/
  head/
  menu/
  page/
  search/
```

Папку `blocks` можно подключить к новому проекту прямо из репозитория. В этом случае код блока будет храниться только в одном месте, что сэкономит время при исправлении ошибок и внесении изменений.

### Уровни переопределения
Если группа блоков одного проекта, объединённая в папку, подключена к другому проекту напрямую
(при помощи частичного чекаута или *svn:externals*), то любое закоммиченное изменение в таких блоках
повлияет на оба проекта.

При разработке нового сайта на основе существующего может потребоваться
  * увеличить шрифт в `Шапке` на всём сайте, или
  * добавить анимацию для раскрытия всех выпадающих меню - не затрагивая исходный сайт.

Таким образом, важно уметь переопределять (или доопределять) блоки в разных технологиях только для конкретного сайта или только для конкретных страниц. Это возможно при использовании `уровней переопределения`.

`Уровень переопределения` — это набор реализаций блоков, сгруппированных в одну директорию.

![Набор реализаций блоков](http://img-fotki.yandex.ru/get/9107/221798411.0/0_babc3_6eb2cfbf_XXL.png)

Реализация любого блока библиотеки может быть расширена (или переопределена) на уровне проекта.

![Переопределение на уровне проекта](http://img-fotki.yandex.ru/get/9515/221798411.0/0_babc2_3e8566e4_XXL.png)

**С точки зрения сборки страниц**, для каждой страницы можно указать список уровней (директорий), блоки которых будут
    представлены на странице.  
    Например, `build-page -l blocks-common -l blocks-my my-page.html`.

**С точки зрения файловой структуры**, проект может содержать любое количество реализаций блоков. Но на страницу попадут только те,
    которые явно указаны к применению для сборки этой страницы. Возможно задавать разные наборы
    уровней переопределения для разных разделов сайтов.

**С точки зрения JavaScript**, появляется возможность декларативного описания динамического поведения элементов на странице.
    Конечное поведение должно собираться из разных уровней переопределения. Например,

```js
/* blocks-common/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    …
  }
});

/* blocks-my/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    this.__base();
    …
  }
});
```

**С точки зрения шаблонного движка**, для того, чтобы можно было не только переопределять, но и *доопределять* шаблон, нужен способ вызвать предыдущую реализацию шаблона.  
    Например, в случае XSL:

```xml
<xsl:template match="b:head">
  <div> <!-- Node for extra design -->
    <xsl:apply-imports/>
  </div>
</xsl:template>
```

**С точки зрения архитектуры проекта**:
  * При разработке портала из нескольких сайтов, можно выделить общую библиотеку блоков, которая станет
    одним из уровней переопределения для всех сайтов портала. Блоки конкретного сайта объединяются в
    другой уровень переопределения.
  * В одном и том же репозитории может храниться реализация сайта для десктопных и мобильных браузеров. В таком проекте есть уровни переопределения для общей реализации блоков, для мобильной и для десктопной.
    Различные комбинации уровней дают желаемую реализацию блоков на конкретных страницах.

Примером реализации нескольких уровней переопределения в одном репозитории может служить
open-source библиотека блоков [bem-bl](http://ru.bem.info/libs/bem-bl/dev/).

### Сборка страниц
Работа со страницей в терминах блоков подразумевает `предметную абстракцию`. Эта предметная абстракция
обязательна только на уровне взаимодействия человека с кодом.

Когда код попадает в браузер, наличие предметной абстракции необязательно - важно лишь сохранить требуемый
внешний вид и поведение блоков на странице.

Таким образом, `код для людей` и `код для браузеров` — не одно и то же:
  * человек пишет код блоков — браузер получает код целой страницы.

Для того, чтобы превратить код для людей в код для браузеров мы осуществляем `сборку страниц`.

`Сборка страницы` — это формирование кода страницы в различных технологиях
(HTML, CSS, JavaScript) на основе декларативного описания страницы (XML, JSON)
путём применения реализаций описанных блоков.

**С точки зрения CSS**:
  * Файлы всех блоков собираются в один файл страницы.  
    Несмотря на то, что CSS для каждого блока, элемента и модификатора реализован в отдельных файлах,
    для работы страницы нет необходимости подключать эти файлы *as is*. Всю необходимую CSS-реализацию
    страницы можно собрать в один файл. К тому же, это решает такие проблемы, как ограниченное количество импортов
    в IE, и уменьшает число HTTP-запросов к серверу. Объединение всех CSS в один файл происходит при помощи
    утилиты [borschik](http://ru.bem.info/tools/optimizers/borschik/).
  * Браузер получает минимизированный код.
    В процессе сборки можно минимизировать и оптимизировать CSS-код. Например, при помощи утилиты
    [CSSO](https://github.com/css/csso).
  * Каждый браузер получает CSS, написанный специально для него.  
    Удобно разделять CSS-реализации для разных браузеров и поставлять в каждый конкретный
    браузер только тот CSS, который нужен ему. Для этого можно использовать прототип [Сеточка](https://github.com/afelix/setochka).

**С точки зрения JavaScript**, много файлов для блоков - один файл для страницы.  
Так же, как и в случае c CSS, JavaScript-реализация всех необходимых блоков может быть объединена в один файл.

**С точки зрения шаблонных движков**, задействуются только нужные шаблоны.  
Конечный набор шаблонов, используемых для вывода HTML-страницы, в результате сборки содержит только
    шаблоны нужных блоков. Благодаря этому увеличивается производительность и уменьшается
    вероятность возникновения побочных эффектов.

**С точки зрения процесса разработки**, роботы на службе у человека - не наоборот.  
Разработчик пишет код так, как ему удобно. О производительности заботятся роботы, которые в процессе
    сборки делают код оптимизированным (и, возможно, нечитаемым).

**С точки зрения организации труда**, обеспечивается его разделение.  
  Одни разработчики создают блоки, другие - занимаются
    оптимизацией конечного продукта.

Для сборки файлов страниц используется набор инструментов [bem-tools](http://ru.bem.info/tools/bem/bem-tools/).

#### Автоматизация сборки
Использование `bem-tools` подразумевает выполнение
нескольких операций для каждой страницы. В результате, на основе BEMJSON-описания
страницы генерируются её CSS и JavaScript файлы, шаблоны и, в случае статической разработки, HTML.

Чтобы не выполнять эти операции вручную, мы добавили в `bem-tools`
команды:

* `bem make` — команда для статической сборки проекта. При запуске собирает все файлы, которые требуют пересборки.

* `bem server` — команда для запуска HTTP-сервера, который при обработке запросов запускает точечную сборку
файлов проекта и после успешного выполнения сборки отдаёт их клиенту.

[Подробнее о командах](http://ru.bem.info/tools/bem/bem-tools/#bem-make).
